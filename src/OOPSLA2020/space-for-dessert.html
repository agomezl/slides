<section style="text-align: left;" data-auto-animate>
  <h4>Do you have space for dessert?</h4>
  <hr/>
  <div class="r-hstack justify-start">
    <div class="r-hstack justify-center" style="align-self: stretch;width: 50%;">
      <div>
        <p>A Verified Space Cost Semantics for <img style="vertical-align:middle;margin:0;" height="42px" src="Lic/CakeML.svg"/> CakeML</p>
      </div>
      <div>

      </div>
    </div>
    <div class="r-hstack justify-end" style="align-self: stretch;width: 50%;">
      <div>
        <table class="authors" style="font-size: 25px;">
          <tbody>
            <tr><td style="text-align: right;">&#x1F5E3</td><td>Alejandro Gómez-Londoño</td></tr>
            <tr><td></td><td>Johannes Åman Pohjola</td></tr>
            <tr><td></td><td>Hira Taqdees Syeda</td></tr>
            <tr><td></td><td>Magnus O. Myreen</td></tr>
            <tr><td></td><td>Yong Kiam Tan</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>Hello</li>
      <li>My name is Alejandro Gomez-Londoño</li>
      <li>And I'm presenting our work in space cost semantics for CakeML programs</li>
      <li>Titled: "Do you have space for dessert?"</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <img style="min-width: 20%;" src="Lic/CakeML.svg"/>
  <aside class="notes">
    <ul>
      <li>First, lets discuss what is CakeML</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-center">
    <div style="width:30%;">
      <img style="min-width: 80%;" src="Lic/CakeML.svg"/>
    </div>
    <div data-id="vl" class="r-hstack" style="width:10%;align-self:stretch;">
      <div class="vl"></div>
    </div>
    <div style="width:50%;">
      <ul>
        <li>Functional language</li>
        <li>Proven-correct compiler</li>
        <li>Able to bootstrap itself</li>
      </ul>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>CakeML is ...</li>
    </ul>

  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-center">
    <div style="width:30%;">
      <img style="min-width: 60%;" src="Lic/CakeML.svg"/>
    </div>
    <div>
      <h2><code>&lt;-&gt;</code></h2>
      <p class="fragment">&#x1F91D;</p>
    </div>
    <div style="width:30%;" class="r-vstack items-center">
      <div style="padding : 10px 20px 10px 20px;" class="block">
        <div><i  class="far fa-file-alt"></i></div>
        <p style="margin:0 0 0 0;"><code>.asm</code></p>
      </div>
    </div>
    <aside class="notes">
      <p> So, using the CakeML compiler one can generate
          from a source program (left)  machine code (right)
          and be sure that the behaviours of both are compatible.
      </p>
    </aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
    <p>&#x1F91D;</p>
    <table class="rule">
      <tbody>
        <tr><td>$\text{machine_sem}\,(\text{compile}\,prog)\,\subseteq\\
          \text{extend_with_resource_limit}(\text{source_sem}\,prog)$</td></tr>
      </tbody>
    </table>
  </div>
  <aside class="notes">
   <ul>
     <li>
       What we mean by compatible in this setting is that all the behaviours
       present in the semantics of the machine code are also present (left)
       in the semantics of the source code (right)
     </li>
     <li>
       Or in other words, the behaviours of the source code are a super
       set of those of the machine code
     </li>
     <li>This allows us to translate safety properties from one side to the other</li>
     <li>However ther is catch!</li>
   </ul>
  </aside>
</section>


<section data-auto-animate>
  <div class="r-vstack items-center">
    <table class="rule">
      <tbody>
        <tr><td style="border: none;">
          $\text{extend_with_resource_limit}(\text{source_sem}\,prog)$
        </td></tr>
        <tr class="fragment"><td style="border: none;">
          <i data-id="a1" class="fas fa-arrow-down"></i>
        </td></tr>
        <tr class="fragment"><td style="border: none;">
          $\text{source_sem}\,prog\,\cup$ &#x1F4A5;
        </td></tr>
      </tbody>
    </table>
  </div>
  <aside class="notes">
    <ul>
      <li>You might have notice that the source sematics is enclosend in this
          <code>extended_with_resorce_limits</code> function
      </li>
      <li>What this does is that it takes all the behaviours of the source semantics
          and extends them with running out of memory behaviours
      </li>
      <li>We need this because the source semantics can not run out of memory</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
    <p>&#x1F91D;</p>
    <table class="rule">
      <tbody>
        <tr><td>$\text{machine_sem}\,(\text{compile}\,prog)\subseteq\\
          \text{extend_with_resource_limit}(\text{source_sem}\,prog)$</td></tr>
      </tbody>
    </table>
  </div>
<aside class="notes">
  <ul>
    <li>So we would like to replace the subset relation with an equality!</li>
  </ul>

</aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
    <p>&#x1F44D;</p>
    <table class="rule">
      <tbody>
        <tr><td>$\text{machine_sem}\,(\text{compile}\,prog)=\text{source_sem}\,prog$</td></tr>
      </tbody>
    </table>
  </div>
  <aside class="notes">
    <ul>
      <li>This will allow us to not only translate safety but liveness
          properties from one side to the other
      </li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
    <p>&#x2705; &#x1F449; &#x1F44D;</p>
    <table class="rule">
      <tbody>
        <tr><td>$\bbox[background-color: #f19a3e]{\text{is_safe}\,prog} \implies \\
          \text{machine_sem}\,(\text{compile}\,prog)=
          \text{source_sem}\,prog$</td></tr>
      </tbody>
    </table>
  </div>
<aside class="notes">
  <ul>
  <li>The approach we tooks was to device a  "safety" predicate over the source program
      which ensures that when compiled the resulting machine code will not run out of memory
  </li>
  <li>This eliminates the need for <code>extend_with_resource_limit</code></li>
</ul>
</aside>
</section>

<section>
  <p>Objectives</p>
  <hr/>
  <ul>
    <li class="fragment fade-up">Make space reasoning <u>possible</u> in <code>CakeML</code></li>
    <li class="fragment fade-up">Produce <u>concrete and tight</u> space bounds</li>
    <li class="fragment fade-up">Enable transportation of <u>liveness</u> properties from source to machine code</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>We set out to do this with the following objectives:</li>
    </ul>
  </aside>
</section>

<section>
  <p>Contributions</p>
  <hr/>
  <ul>
    <li class="fragment fade-up">A formal <u>space cost semantics</u> for <img style="vertical-align:middle;margin:0;" height="42px" src="Lic/CakeML.svg"/> CakeML</li>
    <li class="fragment fade-up">Proof of <u>soundness</u> w.r.t a compiler that relies on (verified) garbage collection</li>
    <li class="fragment fade-up">Prove of <u>concrete and tight bounds</u> for a number of examples (non-terminating, higher-order, and bignum)</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>This papers contributions are</li>
    </ul>
  </aside>
  </section>

<section>
  <p>Why do programs run out of memory?</p>
  <hr/>
  <ul>
    <li class="fragment fade-up">Runs out of heap</li>
    <li class="fragment fade-up">Runs out of stack</li>
    <li class="fragment fade-up">Object exceeds representation limits</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>So why do programs run out of memory any way?</li>
      <li>It can run out of heap</li>
      <ul>
        <li>This is when a single or a set of objects grow so large in size that they
            exhausts the available heap space
        </li>
      </ul>
      <li>Alternatively, it can run out of stack</li>
      <lu><li>Here, a large number of yet-to-return nested functions fill the call-stack completely</li></lu>
      <li>And Finally, and perhaps more exotic, its when an object exceed its representation limit</li>
      <ul>
        <li> For example, if an array representation uses, say, 3bits in its header to keep track of its length,
             one can exceed this representation by simply concatenation to arrays of length 6.
        </li>
      </ul>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <img style="width: 30%;" src="Lic/il.png"/>
  <aside class="notes">
    <ul>
      <li>So where do out-memory-errors appear in CakeML?</li>
      <li>the structure of the CakeML compiler, unsurprisingly,
          looks like a cake, in the sense that it has many layers</li>
      <li>Each the layer corresponds to a compilation phase or an optimization</li>
      <li>This approach keeps things modular for both proofs and implementation</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-center">
    <img style="width: 30%;" src="Lic/il.png"/>
    <div class="r-vstack items-start" style="padding-left:20px">
      <div>
        <i class="fas fa-arrow-up"></i> High level (Tractable)
      </div>
      <div style="align-self:center;padding:30px 0 30px 0">
        <code>??</code>
      </div>
      <div>
        <i class="fas fa-arrow-down"></i> Low level (Precise)
      </div>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>The higher in the stack the more tractable and high level a language is</li>
      <li>While lower levels are more concrete and close to the machine code</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-start">
    <div class="r-vstack items-center">
      <div data-id="il1"><code>CakeML</code></div>
      <div data-id="il2"><code>flatLang</code></div>
      <div data-id="il3"><code>closLang</code></div>
      <div data-id="il4"><code>BVL</code></div>
      <div data-id="il5"><code>BVI</code></div>
      <div data-id="il6"><code>dataLang</code></div>
      <div data-id="il7"><code>wordLang</code></div>
      <div data-id="il8"><code>stackLang</code></div>
      <div data-id="il9"><code>labLang</code></div>
      <div data-id="il10"><code>Machine code</code></div>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>When it comes to the representation of memory, it is worth nothing that...</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-start">
    <div class="r-vstack items-center">
      <div style="color:#f19a3e" data-id="il1"><code>CakeML</code></div>
      <div style="color:#f19a3e" data-id="il2"><code>flatLang</code></div>
      <div style="color:#f19a3e" data-id="il3"><code>closLang</code></div>
      <div style="color:#f19a3e" data-id="il4"><code>BVL</code></div>
      <div style="color:#f19a3e" data-id="il5"><code>BVI</code></div>
      <div style="color:#f19a3e" data-id="il6"><code>dataLang</code></div>
      <div data-id="il7"><code>wordLang</code></div>
      <div data-id="il8"><code>stackLang</code></div>
      <div data-id="il9"><code>labLang</code></div>
      <div data-id="il10"><code>Machine code</code></div>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>The first 6 languages in the stack have semantics that lack any form of out-memory behaviours</li>
      <li>Or in other words, theirs memory models have unlimited space</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
  <div class="r-hstack items-start">
    <div data-id="il1"><code>CakeML</code></div>
    <div data-id="eq1" style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il2"><code>flatLang</code></div>
    <div data-id="eq2" style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il3"><code>closLang</code></div>
    <div data-id="eq3" style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il4"><code>BVL</code></div>
    <div data-id="eq4" style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il5"><code>BVI</code></div>
    <div data-id="eq6" style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il6"><code>dataLang</code></div>
  </div>
  <div class="r-vstack items-center">
    <div data-id="subeq">$\subseteq$</div>
    <div data-id="il7"><code>wordLang</code></div>
    <div data-id="il8"><code>stackLang</code></div>
    <div data-id="il9"><code>labLang</code></div>
    <div data-id="il10"><code>Machine code</code></div>
  </div>
  </div>
  <aside class="notes">
    <ul>
      <li>So the relationship between the behaviours of these languages is an equality</li>
      <li>It is only at the point when memory become more concrete that the subset relation is introduced</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
    <div class="r-hstack items-start">
      <div data-id="il1"><code>CakeML</code></div>
      <div data-id="eq1" style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il2"><code>flatLang</code></div>
      <div data-id="eq2" style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il3"><code>closLang</code></div>
      <div data-id="eq3" style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il4"><code>BVL</code></div>
      <div data-id="eq4" style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il5"><code>BVI</code></div>
      <div data-id="eq6" style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il6"><code>dataLang</code></div>
    </div>
    <div class="r-vstack items-center">
      <div data-id="subeq">$\subseteq$</div>
    </div>
    <div class="r-hstack items-start">
      <div data-id="il7"><code>wordLang</code></div>
      <div style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il8"><code>stackLang</code></div>
      <div style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il9"><code>labLang</code></div>
      <div style="margin:0 10pt 0 10pt"><code> = </code></div>
      <div data-id="il10"><code>Machine code</code></div>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>It is worth noting that all the languages at the bottom also share an equality relation</li>
      <li>So, when we considered where to do our space reasoning the first obvious candidate was...</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-start">
    <div data-id="il1"><code>CakeML</code></div>
  </div>
  <hr/>
  <div class="r-hstack items-start">
    <div style="width : 50%;">
    <ul class="up-list">
      <li class="fragment fade-up">Source language</li>
      <li class="fragment fade-up">High level</li>
    </ul>
    </div>
    <div style="width : 50%;">
    <ul class="down-list">
      <li class="fragment fade-up">Complex cost-semantics</li>
      <li class="fragment fade-up">Loose approximation</li>
    </ul>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>CakeML</li>
      <li>It is the source language after all, and is what you use to write your programs</li>
      <li>It is high level so one does not have to deal with allocation or pointer as much</li>
      <li>However, the initially great upsides very quicky turn into downsides</li>
      <li>Extending the source semantics to accommodate a space reasoning at such a
          high level in the language stack requires either:</li>
        <ul>
          <li>A complex space semantics that contains basically all compilers phases and optimizations within it</li>
          <li>Or Completely ignore all that and provide a very loose upper bound</li>
        </ul>
      <li>Both of those alternatives did not met our objectives so we went back to the drawing board</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-vstack items-center">
  <div class="r-hstack items-start">
    <div data-id="il1"><code>CakeML</code></div>
    <div style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il2"><code>flatLang</code></div>
    <div style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il3"><code>closLang</code></div>
    <div style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il4"><code>BVL</code></div>
    <div style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il5"><code>BVI</code></div>
    <div style="margin:0 10pt 0 10pt"><code> = </code></div>
    <div data-id="il6"><code>dataLang</code></div>
  </div>
  <div class="r-vstack items-center">
    <div>$\subseteq$</div>
    <div data-id="il7"><code>wordLang</code></div>
    <div data-id="il8"><code>stackLang</code></div>
    <div data-id="il9"><code>labLang</code></div>
    <div data-id="il10"><code>Machine code</code></div>
  </div>
  </div>
  <aside class="notes">
    <ul>
      <li>We notes that among all the "high level" languages <code>dataLang</code>
          had a number of interesting features</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div class="r-hstack items-start">
    <div data-id="il6"><code>dataLang</code></div>
  </div>
  <hr/>
  <ul>
    <li class="fragment fade-up">Imperative</li>
    <li class="fragment fade-up">Abstract values</li>
    <li class="fragment fade-up">Stateful storage</li>
    <li class="fragment fade-up">An explicit call-stack
      <span class=fragment style="color:#f19a3e;">(unlike languages above)</span></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>It is imperative, so it is easy to step through each instruction and see what effect it had on memory</li>
      <li>It provides abstract values, meaning not everything is represented using and there is a bit of structure to values</li>
      <li>It has stateful storage, so actual variables instead of bindings</li>
      <li>And finally, it has an explicit call-stack, unlike all languages above it</li>
      <li>So pretty much everything we need to be able to reason about running out of memory is here
          in a concrete enough way, a stack, the heap, variables and values.
      </li>
      <li>Additionally, it gets bonus points for being at a place in the language stack where most optimizations
          and tricky compiler phases have already happened simplifying our task greatly</li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <pre><code class="hljs haskell" data-trim>
    FOLDL f e [] = e
    FOLDL f e (x::xs) = FOLDL f (f e x) xs
  </code></pre>
  <hr/>
  <pre><code class="hljs python" data-trim data-line-numbers>
    foldl [0; 1; 2] = # FOLDL (0=l) (1=e) (2=f)
      # LENGTH l = 0?
      do 4 :≡ (TagLenEq 0 0,[0],NONE);
         if_var 4 (return 1) # Nil case, return e
           # Cons case
           do 6 :≡ (ElemAt 0,[0],NONE);  # head (x)
              7 :≡ (ElemAt 1,[0],NONE);  # tail (xs)
              ...
              # f x e
              call (18,⦕ 2; 7 ⦖) NONE [6; 1; 2; 15] NONE;
              tailcall_foldl [7; 18; 2]
  </code></pre>
  <aside class="notes">
    <ul>
      <li>
        However, <code>dataLang</code> is NOT source CakeML and there
        is of course a clear downside from writing your programs on a language and
        have to reason about it in another.
      </li>
      <li>
        But we have improved our infrastructure to facilitate this task,
        as much as possible.
      </li>
      <li>
        Lets consider as an example the <code>FOLDL</code> function,
        implemented in the source language at the top
        and compiled into dataLang at the bottom
      </li>
      <li>
        Variables in data lang are numeric thus to better show the similarity
        we replace them here with their corresponding source names.
        However, the relation between them is still one-to-one.
      </li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <pre><code class="hljs haskell" data-trim>
    FOLDL f e [] = e
    FOLDL f e (x::xs) = FOLDL f (f e x) xs
  </code></pre>
  <hr/>
  <pre><code class="hljs python" data-trim data-line-numbers="|1|2-4|6-8|10-12">
    foldl [l; e; f] =
      # LENGTH l = 0?
      do isNil :≡ (TagLenEq 0 0,[l],NONE);
         if_var isNil (return e) # Nil case, return e
           # Cons case
           do x  :≡ (ElemAt 0,[l],NONE);  # head
              xs :≡ (ElemAt 1,[l],NONE);  # tail
              ...
              # f x e
              call (e1,⦕ f; xs ⦖) NONE [x; e; f] NONE;
              tailcall_foldl [xs; e1; f]
  </code></pre>
  <aside class="notes">
    <ul>
      <li>
        dataLang can be displayed using a monadic representation, which improves readability
      </li>
      <li>
        Function names are preserved all the way from source into dataLang so it is easy to know what is what
      </li>
      <li>Arguments are the same, just in reverse</li>
      <li>First a case distinction is performed</li>
      <li>On the nil case the base value is returned </li>
      <li>For the cons case, head and tail are obtaines
        and the new base value is computed by calling
        function f with the corresponding arguments
      </li>
      <li>Finally a tail recursive call is performed</li>
    </ul>
  </aside>
</section>


<section>
  <div class="r-hstack items-center">
    <pre><code class="hljs haskell" data-trim>
         v = Number  int
           | Word64  word64
           | Block   ts tag (v list)  -- ts = tag = num
           | CodePtr num
           | RefPtr  num
    </code></pre>
  </div>
  <aside class="notes">
    <ul>
      <li>Values in dataLang are presented by this data type</li>
      <ul>
        <li>We have unbounded integers</li>
        <li>Words</li>
        <li>Blocks of contiguous values with a constructor tag and a uniqueness timestamp</li>
        <li>Code pointer</li>
        <li>Value pointers</li>
      </ul>
    </ul>
  </aside>
</section>

<section>
  <h3><code>[1,2,3]</code></h3>
  <div class="fragment fade-up" style="margin-top:1em">
    <hr/>
    <pre><code class="hljs haskell" data-trim>
      Block 8 cons_tag [Number 1;
        Block 7 cons_tag [Number 2;
          Block 6 cons_tag [Number 3;
            Block 0 nil_tag []
          ]
        ]
      ]
    </code></pre>
  </div>
  <aside class="notes">
    <ul>
      <li>As an example lets take the list <code>[1,2,3]</code> which is represented in dataLang as follows</li>
      <ul>
        <li>The first block contains contains the head of the list (<code>Number 1</code>) as its first value</li>
        <li>Followed by the tail of the list, which is again a list and is represented with a block as well</li>
        <li>The tail follows the same structure as before, with its firs element (<code>Number 2</code>) being the head of the tail</li>
        <li>Followed again by the tail of the tail</li>
        <li>You can see how the original structure of the list value is represented using blocks</li>
        <li>It is also worth pointing out that each block represents a constructor which is identified by the tag value</li>
        <li>and that each non-empty block has an unique timestamp</li>
      </ul>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div data-id="t1"><code>evaluate (prog,s) = (res,s')</code></div>
  <div class="fragment fade-up" style="margin-top:1em">
    <hr/>
    <pre data-id="c1"><code class="hljs haskell" data-trim data-line-numbers="|1|2|3|4">
      state = <| locals           : v num_map
               ; stack            : stack list
               ; refs             : v ref num_map
               ; global           : num option
               ...
               |>
    </code></pre>
  </div>
  <aside class="notes">
    <ul>
      <li>The semantics of dataLang is defined using a functional bigstep semantics</li>
      <li>it takes a program and a state, and returns a result with an updated state</li>
      <li>The state contains everything needed to execute the dataLang program, here we
          display only the field relevant to our memory model
      </li>
      <ul>
        <li><code>locals</code> contains all variables in the scope of the current function</li>
        <li><code>stack</code> is the call-stack</li>
        <li><code>refs</code> is a map from pointers to values</li>
        <li>and <code>global</code> contains global values that can be accessed from everywhere</li>
      </ul>
      <li>We can see from the state then, that even though dataLang's memory model is unbounded,
          one can still concretely "see" both heap and stack
      </li>
    </ul>
  </aside>
</section>

<section data-auto-animate>
  <div data-id="t1"><code>evaluate (prog,s) = (res,s')</code></div>
  <div style="margin-top:1em">
    <hr/>
    <pre data-id="c1"><code class="hljs haskell" data-trim data-line-numbers="|5|6|7">
      state = <| locals           : v num_map
               ; stack            : stack list
               ; refs             : v ref num_map
               ; global           : num option
               ; limits           : limits
               ; safe_for_space   : bool
               ; stack_max        : num option
               ...
               |>
    </code></pre>
  </div>
  <aside class="notes">
    <ul>
      <li>So, to keep track of memory consumption we extended with a number of extra fields</li>
      <ul>
        <li><code>limits</code> contains concrete bounds for heap and stack</li>
        <li>
            <code>safe_for_space</code> is always initially true and signals when
            the programs has surpassed one of the <code>limits</code>
        </li>
        <li><code>stack_max</code> records the maximum stack size seen during execution</li>
      </ul>
      <li>With this we have everything we need to measure and keep track of memory, how do we do it then?</li>
    </ul>
  </aside>
</section>

<section>
  <div class="r-hstack items-start">
    <div style="width:45%;">
      <pre><code class="hljs haskell">size_of_heap s</code></pre>
      <ul>
        <li class="fragment fade-right">At every allocation</li>
        <li class="fragment fade-right">On heap consuming operations</li>
      </ul>
    </div>
    <div data-id="vl" class="r-hstack" style="width:10%;align-self:stretch;">
      <div class="vl"></div>
    </div>
    <div style="width:45%;">
      <pre><code class="hljs haskell">size_of_stack s.stack</code></pre>
      <ul>
        <li class="fragment fade-left">At every function call</li>
        <li class="fragment fade-left">On stack consuming operations</li>
      </ul>
    </div>
  </div>
  <aside class="notes">
    <ul>
      <li>The main ideas is to measure the size of both heap and stack at relevant points during execution</li>
      <li>We measure heap at every allocation</li>
      <li>and before every heap consuming operations, for example, the addition of two bignums which might
          require allocating some extra space for its result
      </li>
      <li>The size of the stack is measured at every function call</li>
      <li>and before each stack consuming operations, this are operation
          that are implemented in lower languages either recursively or as
          multiple calls to other functions
      </li>
      <li>By doing this we can make sure space consumptions remains withing the limits, or,
          in case it doesn't, set <code>safe_for_space</code> to false
      </li>
    </ul>

  </aside>
</section>

<section>
  <div><code>size_of_stack s.stack</code></div>
  <div style="margin-top:20px">
    <hr/>
    <pre data-id="c1"><code class="hljs haskell" data-trim data-line-numbers="|5|1,2,6">
        let new_stack = MAX s.stack_max
                            (size_of_stack s.stack)
        in
          s with <| safe_for_space :=
                      s.safe_for_space ∧
                      new_stack < s.limits.stack_limit;
                    stack_max := new_stack |>
    </code></pre>
  </div>
  <aside class="notes">
    <ul>
      <li>This is the measurement of stack size that is performed after a function call</li>
      <li>First we make a conjunction with the current value of <code>safe_for_space</code></li>
      <li>Then we measure the current size of the stack, and obtain the maximum this measurement and the largest previous measurement</li>
      <li>We check if this <code>new_stack</code> is still within the limits and update <code>safe_for_space</code> accordingly</li>
      <li>Finally we update <code>stack_max</code> to reflect any changes</li>
    </ul>
  </aside>
</section>

<section>
  <div><code>size_of_heap s</code></div>
  <div style="margin-top:20px">
    <hr/>
    <pre data-id="c1"><code class="hljs haskell" data-trim data-line-numbers="|4|1,5">
        let new_heap = size_of_heap s + space_consumed s op vs
        in
          s with <| safe_for_space :=
                      s.safe_for_space ∧
                      new_heap < s.limits.heap_limit |>
    </code></pre>
  </div>
  <aside class="notes">
    <ul>
      <li>Conversely, this is the measurement of heap size before a heap consuming operation is performed</li>
      <li>Again, we make a conjunction with the current value of <code>safe_for_space</code></li>
      <li>Then we measure the amount of heap performing the operation will require, this is, the size of
          the current heap plus the space needed to perform the operation</li>
      <li><code>space_consumed</code> is a characterization of the space needed to perform an operation in terms of its arguments</li>
      <li>Finally, we check if our <code>new_heap</code> is within the limits and update <code>safe_for_space</code> accordingly</li>
      <li>This extra measurements and checks are the only changes made to the semantics
      </li>
      <li>
        No new behaviours where added to dataLang's semantics; In fact, if one ignores the new fields the final result is the same as it
        was before the changes
      </li>
      <li>
        If <code>safe_for_space</code> turns false at any point the semantics will continue evaluating the program.
      </li>
      <li>
        However, the state of the final result will contain via <code>safe_for_space</code>
        an indicator of wether or not our program has ran out of memory
      </li>
    </ul>

  </aside>

</section>

<section>
  <p>How do we count?</p>
</section>

<section data-auto-animate>
  <div><code>size_of vals refs seen</code></div>
  <div style="margin-top:1em">
    <hr/>
    <p style="text-align:left">Where:</p>
    <ul>
      <li>(<code>vals</code>) is a list of <code>v</code> values</li>
      <li>(<code>refs</code>) is a mapping from numbers to values</li>
      <li>(<code>seen</code>) timestamps we have already seen</li>
    </ul>
  </div>
  <aside class="notes">
    <ul>
      <li>We measure using the function <code>size_of</code></li>
      <li>It takes as arguments</li>
      <ul>
        <li>A list of values</li>
        <li>A mapping from number to values, this is what pointer are pointing to</li>
        <li>And a set of seen timestamps</li>
      </ul>
      <li> <code>size_of</code> traverses the list measuring the size of each value,
           but it make sure to avoid counting the same pointer multiple times, and
           mitigates aliasing of blocks using timestamps
      </li>
    </ul>
  </aside>
</section>

<section>
  <pre><code class="hljs haskell" data-trim data-line-numbers="3">
      v = Number  int
        | Word64  word64
        | Block   ts tag (v list) -- ts = tag = num
        | CodePtr num
        | RefPtr  num
  </code></pre>
  <hr/>
  <pre><code class="hljs haskell" data-trim>
    Block 8 cons_tag [Number 1;
      Block 7 cons_tag [Number 2;
        Block 6 cons_tag [Number 3,
          Block 0 nil_tag []
        ]
      ]
    ]
  </code></pre>
  <aside class="notes">
    <ul>
      <li>To see how this works lets briefly recall how values are represented in dataLang</li>
      <li>Specifically how a block contain not only a list of
          values and a constructor tag but an uniquely identifying timestamp</li>
      <li>This timestamp is important since the semantics ensures that if two blocks have the same timestamps their
          contents must be the same, because they are the same value in memory
      </li>
    </ul>
  </aside>
</section>

<section>
  <pre><code class="hljs haskell" data-trim>
    size_of [Block 3 some_tag [Number 1];
             Block 3 some_tag [Number 1]]
            refs seen
  </code></pre>
  <div>
    <i class="fas fa-arrow-down"></i>
  </div>
  <pre><code class="hljs haskell" data-trim>
    2 +
    size_of [Block 3 some_tag [Number 1]]
            refs ({3} ∪ seen)
  </code></pre>
  <div>
    <i class="fas fa-arrow-down"></i>
  </div>
  <pre><code class="hljs haskell" data-trim>
    2
  </code></pre>
  <aside class="notes">
    <ul>
      <li>In this example we are measuring the size of two blocks, we assume <code>seen</code>
          is initially empty and <code>refs</code> is the one currently in the state</li>
      <li>The size of the first block is 2, one word for its tag, and one for its only element the small number 1</li>
      <li>We continue traversing the list, but the set of seen timestamps is updated with the timestamp we just saw</li>
      <li>So when we reach the next block we check if the timestamp has already been seen, this is in deed the case</li>
      <li>This means we don't need to measure this block since its size has already been accounted for</li>
    </ul>
  </aside>
</section>

<section>
  <p>What do we count?</p>
</section>

<section>
  <div><code>size_of_heap s</code></div>
  <div style="margin-top:0.3em">
    <hr/>
    <div class="r-vstack items-center fragment fade-up"
         data-fragment-index="1">
      <code>size_of <span hl>reachabe_values</span> s.refs {}</code>
      <div class="fragment" data-fragment-index="2">
        <h2><i class="fas fa-arrow-down"></i></h2>
      </div>
      <div class="fragment" style="width:80%"
           data-fragment-index="2">
      <pre><code class="hljs haskell" data-trim>
       <|s.locals|> ++ <|s.stack|> ++ <|s.global|>
      </code></pre>
      </div>
  </div>
</section>

<section data-auto-animate data-background="https://media.giphy.com/media/acttIrNAHaoco/giphy.gif">
  <div style="background-color: rgba(0, 0, 0, 0.8); color: #fff; padding: 10px;">
    <h3><code>size_of_heap s = <br>
          size_of_heap (run_gc s)</code></h3>
  </div>
</section>

<section>
  <p>Putting it all together</p>
</section>

<section>
  <pre><code class="hljs haskell" data-trim>
    is_safe s prog =
       let (res,s') = evaluate (prog,s)
       in s'.safe_for_space
  </code></pre>
</section>

<section>
  <div class="r-vstack items-center">
    <table class="rule">
      <tbody>
        <tr><td>$\text{machine_sem}\,(\text{compile}\,prog)\,\subseteq\\
          \text{extend_with_resource_limit}(\text{source_sem}\,prog)$</td></tr>
      </tbody>
    </table>
  </div>
</section>

<section>
  <div class="r-vstack items-center">
    <table class="rule">
      <tbody>
        <tr><td>$\text{is_safe}\,\text{init_s}\,(\text{to_data}\,prog) \implies \\
          \text{machine_sem}\,(\text{compile}\,prog)=\text{source_sem}\,prog$</td></tr>
      </tbody>
    </table>
  </div>
  <div class="fragment fade-up"><i>(See paper for actual statement.)</i></div>
</section>

<section>
  <p>Conclusion</p>
  <hr/>
  <ul>
    <li class="fragment fade-up">We use <code>dataLang</code> as a space cost semantics for <img style="vertical-align:middle;margin:0;" height="42px" src="Lic/CakeML.svg"/></li>
    <li class="fragment fade-up">Space cost is precisely measured by <code>size_of</code></li>
    <li class="fragment fade-up">Timestamps are used to mitigate aliasing</li>
    <li class="fragment fade-up">By only counting reachable objects our measurement is idempotent over GC passes</li>
  </ul>
  </section>

<section>
  <h1><img style="vertical-align:middle;margin:0;" src="Lic/CakeML.svg"/></li>?</h1>
</section>